# securingsoftware
<h1>MOOC.fi Securing Software course</h1>
<br/>
<b>Install instructions<b/>
No specific instruction are needed for installation – the application uses the same  Django framework used by the course. Clone the repo, and run "python manage.py runserver" from the command line.
<br/>
<b>Intro<b/>
<br/>
This is the project I submission for MOOC.fi's 'Securing Software' course. The brief was to write an application that contains 5 vulnerabilities from the OWASP top 10 list. 
<br/>
<b>FLAW 1: Sensitive data exposure<b/>
<br/>The flaw: When it comes to banking, almost all data related to the users can be considered sensitive. The current site runs over HTTP and operated using GET requests; this means an attacker can essentially gain a full account of a user's activity with the bank, such as usernames, other usernames and account activity conducted.  A more general issue of this vulnerability is also the possibility of GET request reloads triggering multiple actions; this could be a case of the user inadvertently triggering the operation more than once in the 'deposit' or 'withdrawal' functions, or something more malicious occurring.
<br/>Fixing it: In order to limit potential data exposure, configuring the site run over  HTTPS is essential. This will provide encryption critical to protecting the sensitive data generated by the bank customers, as the headers will be encrypted to avoid stackers gleaning information. CSRF and session cookies should also be set to secure to ensure they are encrypted as well. Finally, setting request to the POST method where possible will provide (limited) protection, by ensuring specific parameters (such as usernames and amount of money transferred) aren't present in HTTP headers. In terms of triggering actions more than once, POST requests will provide a warning before they're reloaded which is more likely to reduce user error. An alternative is to implement the confirmation screen functionality seen with with the 'transfer' function; this performs a similar function to the POST request in that it provides an extra prompt to the user.

<b>FLAW 2: Broken authentication<b/>
<br/>Regarding this site, the most straightforward vulnerability is also the most dangerous. In this site, the admin gateway remains at its default 'admin' URL. The username is 'admin' and password is 'password', which is so straightforward any attacker may well end up guessing it without even needing to think about brute-force attacks. Once logged into the admin gateway, and attacker would have full control over the data on the sire, allowing them to create and delete users, reassign funds and more.
<br/>Fixing it: The fix specified here is relatively straightforward. Firstly, changing the 'admin' PATH to a less predictable URL, in order to provide a less straightforward way for any attacker to identify a point to attempt to brute force access. The other mitigation is to choose more secure login credentials beyond an extremely basic combination of username and password that can be guessed instantly. Ensuring an appropriately strong password will prevent brute-forcing, and a non-obvious username will make this exercise more difficult. Other options are also available, such as exploring implementations that allow for two-factor authentication. Finally, considering whether a super-user is actually necessary is also a consideration, depending on the implementation and use case of the site.

<b>FLAW 3:  Security misconfigurationS<b/>
<br/>The flaw: When deploying a Django application, the creator needs to ensure that the framework is properly configured and ready for deployment into the real world. In this case, I'd like to highlight two specific factors which add to the vulnerabilities in this situation. Firstly, a lack of consistent use of CSRF tokens raises the possibility of a malicious actor undertaking a CSRF attack and using a malicious script on a separate site to conduct an unauthorised transfer of funds. Secondly, Django's debug mode remains on – this results in detailed accounts of exactly why an error has occurred (such as detailing all PATHs tried for a 404 error), rather than simply displaying an error message. This gives an attacker a lot of information to help pinpoint vulnerabilities.
<br/>Fixing it: This is a relatively simple fix in both cases. Including {% csrf token %} prior to data being transmitted will protect against CSRF attacks. In settings, setting debug mode to "false" will ensure all errors amply return the category of error without any further information.

<b>FLAW 4: InjectionS<b/>
<br/>This site has a (very) basic message board functionality, where a user can submit some text which other users can select to view subsequently. This function is performed by the user typing in the other user's name; this input is then passed directly into a query to select the relevant message from the site's database. As a result of this, a malicious actor could use specific characters designed to escape the intended query, and run a query of the attacker's choosing. Multiple injection queries would allow the attacker to build up a knowledge of the database schema, and could lead to the egress or deletion of sensitive information.
<br/>Fixing it: The fix in this application is contingent upon presuming that an attacker will attempt to undertake an injection attack. An initial safeguard will be to change the format of selecting a user to see their message; changing this to a drop down, or other format which involved selecting from a set list, will remove the opportunity to inject a malicious query at this point. This is a simpler mitigation than the other option of ensuring the input only consists of whitelisted characters. Changing the type of request from GET to POST will make it less straightforward to insert injection into the URL. However, the key mitigation against this vulnerability is parametrising the query strings that are used to make up the SQL query itself. This means that the user input isn't inserted directly into the query, but passed in through a placeholder.

<b>FLAW 5: XSS<b/>
<br/>As part of the very basic message board functionality in this site, the user can leave a message that others can choose to view. This message input isn't sanitised, and indeed is categorised as 'safe' when passed as a variable within Django into the message viewing page for another user. The example in this case is simply coping the XSS example from earlier in the course, to show that the end user will only see the message text at the beginning of the input, not the JavaScript function  tacked onto it. A more sophisticated query from an attacker could therefore egress session data or a range of sensitive information to a location nominated by an attacker, who could then use it to launch further exploits.
<br/>Fixing it: The immediate solution would not be marking the user's message input as 'safe', which provides an opportunity to escape any identified scripts. In this way, we can use Django's built in features to help prevent XSS, which is something that can be done in multiple other frameworks (such as Ruby on Rails). As an extension of treating the user's input as untrusted, it should be validated and encoded appropriately (in this case into HTML) before being displayed to any other user.
